#include <stdio.h>
#include <math.h>

#include "stm32f10x.h"
#include "stm32f10x_conf.h"
#include "stm32f10x_it.h"
#include "ili932x.h"
#include "touch.h"
#include "hardware.h"

__IO uint32_t TimeFromRTC = 0;

#define LCD_MAX_X 240
#define LCD_MAX_Y 320
#define RECT_SIZE 30
#define MOVE_STEP 5

void NVIC_Configuration_TouchScreenPen(void);

void NVIC_Configuration_RTC(void);
void RTC_Configuration(void);

int Check_Rect_Pos_X(int posx, int currFlag);
int Check_Rect_Pos_Y(int posy, int currFlag);
int Check_Touch_Pos_X(int posx);
int Check_Touch_Pos_Y(int posy);

void Write_Rect(int posx, int posy, int color);

int main(void) {
	
	/* Current rect position */
	int position_X = 0;
	int position_Y = 0;
	
	/* Flags that determines move directions */
	int dirFlagX = 0;
	int dirFlagY = 0;
	
	int rectSize = RECT_SIZE;

	SystemInit();	

	/* RTC interrupt configuration*/
	NVIC_Configuration_RTC();
	
	/* RTC Configuration */
	RTC_Configuration();

	/* Clear reset flags */
	RCC_ClearFlag();

	/* NVIC to enable interrupt on screen touch */
	NVIC_Configuration_TouchScreenPen();

	/* touch screen */
	Touch_Init();

	/* init LCD */
	LCD_Init();
	LCD_Clear(BLACK);

	//LCD_Fill(dupa1,dupa2,dupa1+30,dupa2+30,100);

	while (1)
	{

	    if (TimeFromRTC == 1)
	    {

	    	//LCD_Fill(position_X-RECT_SIZE/2,position_Y-RECT_SIZE/2,position_X+RECT_SIZE/2,position_Y+RECT_SIZE/2,BLACK);
	    	Write_Rect(position_X, position_Y, BLACK);   	
			
	    	
	    	if (dirFlagX == 0 && dirFlagY == 0) {
				position_X = position_X + MOVE_STEP;
				position_Y = position_Y + MOVE_STEP;
			} 
			else if (dirFlagX == 1 && dirFlagY == 0) {
				position_X = position_X - MOVE_STEP;
				position_Y = position_Y + MOVE_STEP;
			}
			else if (dirFlagX == 1 && dirFlagY == 1) {
				position_X = position_X - MOVE_STEP;
				position_Y = position_Y - MOVE_STEP;
			}
			else if (dirFlagX == 0 && dirFlagY == 1) {
				position_X = position_X + MOVE_STEP;
				position_Y = position_Y - MOVE_STEP;
			}
			
			//position_X = Check_Touch_Pos_X(position_X);
			//position_Y = Check_Touch_Pos_Y(position_Y);
			
			Write_Rect(position_X, position_Y, YELLOW);   	
			//LCD_Fill(position_X-RECT_SIZE/2,position_Y-RECT_SIZE/2,position_X+RECT_SIZE/2,position_Y+RECT_SIZE/2,YELLOW);
			
			dirFlagX = Check_Rect_Pos_X(position_X, dirFlagX);
			dirFlagY = Check_Rect_Pos_Y(position_Y, dirFlagY);					

			TimeFromRTC = 0;
	    }
	    		/* If screen have been touched */
		if(Pen_Point.Key_Sta==Key_Down)
		{
			Pen_Int_Set(0); 
			{
				/* Get new touch positon and change rectangle pos */
				Convert_Pos();
				Pen_Point.Key_Sta=Key_Up;
				//LCD_Fill(position_X-RECT_SIZE/2,position_Y-RECT_SIZE/2,position_X+RECT_SIZE/2,position_Y+RECT_SIZE/2,BLACK);
		        //position_X = Pen_Point.X0;
		        position_X = Check_Touch_Pos_X(Pen_Point.X0);
		        //position_Y = Pen_Point.Y0;
		        position_Y = Check_Touch_Pos_Y(Pen_Point.Y0);

			}while(PEN==0);

			Pen_Int_Set(1); // turn interrupt back on
		}

	}
}

int Check_Rect_Pos_X(int posx, int currFlag)
{
	if (posx <= RECT_SIZE/2) return 0;
	else if (posx > LCD_MAX_X - RECT_SIZE/2) return 1;
	else return currFlag;
}

int Check_Rect_Pos_Y(int posy, int currFlag)
{
	if (posy <= RECT_SIZE/2) return 0;
	else if (posy > LCD_MAX_Y - RECT_SIZE/2) return 1;
	else return currFlag;
}		

int Check_Touch_Pos_X(int posx)
{
	if (posx <= RECT_SIZE/2) return RECT_SIZE/2;
	else if (posx >= LCD_MAX_X - RECT_SIZE/2) return (LCD_MAX_X - RECT_SIZE/2);
	else return posx;
}

int Check_Touch_Pos_Y(int posy)
{
	if (posy <= RECT_SIZE/2) return RECT_SIZE/2;
	else if (posy >= LCD_MAX_Y - RECT_SIZE/2) return (LCD_MAX_Y - RECT_SIZE/2);
	else return posy;
}

void Write_Rect(int posx, int posy, int color)
{
	if (posx-RECT_SIZE/2 < 0 && posy-RECT_SIZE/2 < 0) {
		LCD_Fill(0,0,posx+RECT_SIZE/2,posy+RECT_SIZE/2,color);
	}
	else if (posx-RECT_SIZE/2 < 0) {
		LCD_Fill(0,posy-RECT_SIZE/2,posx+RECT_SIZE/2,posy+RECT_SIZE/2,color);
	}
	else if (posy-RECT_SIZE/2 < 0) {
		LCD_Fill(posx-RECT_SIZE/2,0,posx+RECT_SIZE/2,posy+RECT_SIZE/2,color);
	}
	else LCD_Fill(posx-RECT_SIZE/2,posy-RECT_SIZE/2,posx+RECT_SIZE/2,posy+RECT_SIZE/2,color);
	
}

void NVIC_Configuration_RTC(void)
{
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Configure one bit for preemption priority */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

  /* Enable the RTC Interrupt */
  NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
}

/* page: 60 */
void RTC_Configuration(void)
{
  /* Enable PWR and BKP clocks */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);

  /* Allow access to BKP Domain */
  PWR_BackupAccessCmd(ENABLE);

  /* Reset Backup Domain */
  BKP_DeInit();

  /* Enable LSE */
  RCC_LSEConfig(RCC_LSE_ON);
  /* Wait till LSE is ready */
  while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
  {}

  /* Select LSE as RTC Clock Source */
  RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);

  /* Enable RTC Clock */
  RCC_RTCCLKCmd(ENABLE);

  /* Wait for RTC registers synchronization */
  RTC_WaitForSynchro();

  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();

  /* Enable the RTC Second */
  RTC_ITConfig(RTC_IT_SEC, ENABLE);

  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();

  /* Set RTC prescaler: set RTC period to 1sec */
  RTC_SetPrescaler(32767/10); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */

  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();
}

/* page: 92 */
void NVIC_Configuration_TouchScreenPen(void)
{
  	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure one bit for preemption priority */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	/* Enable the EXTI15_10_IRQn Interrupt
	 * This will fire when the touch screen pen is down
	 * */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}



